{
  "problems": [
    {
      "id": "isPalindrome",
      "title": "Palindrome Number",
      "description": "Given an integer x, return true if x is a palindrome, and false otherwise.",
      "constraints": "-2^31 <= x <= 2^31 - 1",
      "function_signature": "def isPalindrome(x: int) -> bool:",
      "initial_code": "def isPalindrome(x: int) -> bool:\n    # Your solution here\n    pass",
      "tests": [
        {"input": [121], "expected": true},
        {"input": [-121], "expected": false},
        {"input": [10], "expected": false}
      ]
    },
    {
      "id": "romanToInt",
      "title": "Roman to Integer", 
      "description": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Given a roman numeral, convert it to an integer.",
      "constraints": "1 <= s.length <= 15, s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M')",
      "function_signature": "def romanToInt(s: str) -> int:",
      "initial_code": "def romanToInt(s: str) -> int:\n    # Your solution here\n    pass",
      "tests": [
        {"input": ["III"], "expected": 3},
        {"input": ["LVIII"], "expected": 58},
        {"input": ["MCMXCIV"], "expected": 1994},
        {"input": ["IV"], "expected": 4},
        {"input": ["IX"], "expected": 9}
      ]
    },
    {
      "id": "twoSum",
      "title": "Two Sum",
      "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice.",
      "constraints": "2 <= nums.length <= 10^4, -10^9 <= nums[i] <= 10^9, -10^9 <= target <= 10^9, Only one valid answer exists",
      "function_signature": "def twoSum(nums: List[int], target: int) -> List[int]:",
      "initial_code": "def twoSum(nums: List[int], target: int) -> List[int]:\n    # Your solution here\n    pass",
      "tests": [
        {"input": [[2, 7, 11, 15], 9], "expected": [0, 1]},
        {"input": [[3, 2, 4], 6], "expected": [1, 2]},
        {"input": [[3, 3], 6], "expected": [0, 1]}
      ]
    },
    {
      "id": "addTwoNumbers",
      "title": "Add Two Numbers",
      "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.",
      "constraints": "The number of nodes in each linked list is in the range [1, 100]. 0 <= Node.val <= 9. It is guaranteed that the list represents a number that does not have leading zeros.",
      "function_signature": "def addTwoNumbers(l1: ListNode, l2: ListNode) -> ListNode:",
      "initial_code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef addTwoNumbers(l1: ListNode, l2: ListNode) -> ListNode:\n    # Your solution here\n    pass",
      "tests": [
        {"input": [[2, 4, 3], [5, 6, 4]], "expected": [7, 0, 8]},
        {"input": [[0], [0]], "expected": [0]},
        {"input": [[9, 9, 9, 9, 9, 9, 9], [9, 9, 9, 9]], "expected": [8, 9, 9, 9, 0, 0, 0, 1]}
      ]
    },
    {
      "id": "longestPalindrome",
      "title": "Longest Palindromic Substring",
      "description": "Given a string s, return the longest palindromic substring in s.",
      "constraints": "1 <= s.length <= 1000, s consist of only digits and English letters.",
      "function_signature": "def longestPalindrome(s: str) -> str:",
      "initial_code": "def longestPalindrome(s: str) -> str:\n    # Your solution here\n    pass",
      "tests": [
        {"input": ["babad"], "expected": "bab"},
        {"input": ["cbbd"], "expected": "bb"}
      ]
    },
    {
      "id": "maxArea",
      "title": "Container With Most Water",
      "description": "Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with the x-axis forms a container, such that the container contains the most water.",
      "constraints": "2 <= height.length <= 10^5, 0 <= height[i] <= 10^4",
      "function_signature": "def maxArea(height: List[int]) -> int:",
      "initial_code": "def maxArea(height: List[int]) -> int:\n    # Your solution here\n    pass",
      "tests": [
        {"input": [[1,8,6,2,5,4,8,3,7]], "expected": 49},
        {"input": [[1,1]], "expected": 1}
      ]
    },
    {
      "id": "mergeKLists",
      "title": "Merge k Sorted Lists", 
      "description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
      "constraints": "k == lists.length\n0 <= k <= 10^4\n0 <= lists[i].length <= 500\n-10^4 <= lists[i][j] <= 10^4\nlists[i] is sorted in ascending order\nThe sum of lists[i].length will not exceed 10^4",
      "function_signature": "def mergeKLists(lists: List[Optional[ListNode]]) -> Optional[ListNode]:",
      "initial_code": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef mergeKLists(lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n    # Your solution here\n    pass",
      "tests": [
        {
          "input": [[[1,4,5],[1,3,4],[2,6]]],
          "expected": [1,1,2,3,4,4,5,6]
        },
        {
          "input": [],
          "expected": []
        },
        {
          "input": [[]],
          "expected": []
        }
      ]
    },
    {
      "id": "findMedianSortedArrays",
      "title": "Median of Two Sorted Arrays",
      "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.",
      "constraints": "nums1.length == m\nnums2.length == n\n0 <= m, n <= 1000\n1 <= m + n <= 2000\n-10^6 <= nums1[i], nums2[i] <= 10^6",
      "function_signature": "def findMedianSortedArrays(nums1: List[int], nums2: List[int]) -> float:",
      "initial_code": "def findMedianSortedArrays(nums1: List[int], nums2: List[int]) -> float:\n    # Your solution here\n    pass",
      "tests": [
        {
          "input": [[1, 3], [2]],
          "expected": 2.0
        },
        {
          "input": [[1, 2], [3, 4]],
          "expected": 2.5
        }
      ]
    },
    {
      "id": "isMatch",
      "title": "Regular Expression Matching",
      "description": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n- '.' Matches any single character.\n- '*' Matches zero or more of the preceding element.\nThe matching should cover the entire input string (not partial).",
      "constraints": "1 <= s.length <= 20\n1 <= p.length <= 30\ns contains only lowercase English letters.\np contains only lowercase English letters, '.', and '*'.\nIt is guaranteed for each appearance of the character '*', there will be a previous valid character to match.",
      "function_signature": "def isMatch(s: str, p: str) -> bool:",
      "initial_code": "def isMatch(s: str, p: str) -> bool:\n    # Your solution here\n    pass",
      "tests": [
        {
          "input": ["aa", "a"],
          "expected": false
        },
        {
          "input": ["aa", "a*"],
          "expected": true
        },
        {
          "input": ["ab", ".*"],
          "expected": true
        }
      ]
    }
  ]
}